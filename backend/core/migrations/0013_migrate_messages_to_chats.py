# Generated by ChatGPT on 2025-12-21

from __future__ import annotations

from collections import defaultdict

from django.db import migrations


def forwards(apps, schema_editor):
    Message = apps.get_model("core", "Message")
    Chat = apps.get_model("core", "Chat")
    ChatMember = apps.get_model("core", "ChatMember")
    ChatMessage = apps.get_model("core", "ChatMessage")

    # If there are no legacy messages, nothing to migrate.
    legacy_qs = Message.objects.all().order_by("id")
    if not legacy_qs.exists():
        return

    def ordered_pair(a_id: int, b_id: int):
        return (a_id, b_id) if a_id < b_id else (b_id, a_id)

    # Collect per-pair stats.
    last_at = {}
    last_id = {}
    unread_by_pair_user = defaultdict(int)  # (pair, user_id) -> unread

    for m in legacy_qs.iterator():
        u1, u2 = ordered_pair(m.sender_id, m.recipient_id)
        key = (u1, u2)
        # last message info
        prev_at = last_at.get(key)
        if prev_at is None or m.created_at > prev_at or (m.created_at == prev_at and m.id > last_id.get(key, 0)):
            last_at[key] = m.created_at
            last_id[key] = m.id
        # unread counts based on legacy is_read per-recipient
        if not getattr(m, "is_read", False):
            unread_by_pair_user[(key, m.recipient_id)] += 1

    # Create / fetch DM chats and memberships.
    pair_to_chat_id = {}
    for (u1, u2), lm_id in last_id.items():
        chat, _ = Chat.objects.get_or_create(
            kind="dm",
            dm_user1_id=u1,
            dm_user2_id=u2,
            defaults={
                "title": "",
                "last_message_at": last_at.get((u1, u2)),
                "last_message_id": lm_id,
            },
        )
        # If chat already existed, still update last-message denorm if empty.
        if chat.last_message_id is None and lm_id is not None:
            Chat.objects.filter(id=chat.id).update(last_message_at=last_at.get((u1, u2)), last_message_id=lm_id)

        pair_to_chat_id[(u1, u2)] = chat.id

        # memberships
        ChatMember.objects.get_or_create(chat_id=chat.id, user_id=u1, defaults={"role": "member"})
        ChatMember.objects.get_or_create(chat_id=chat.id, user_id=u2, defaults={"role": "member"})

    # Create ChatMessage rows, preserving legacy IDs.
    to_create = []
    batch_size = 1000
    for m in legacy_qs.iterator():
        u1, u2 = ordered_pair(m.sender_id, m.recipient_id)
        chat_id = pair_to_chat_id.get((u1, u2))
        if not chat_id:
            continue
        to_create.append(
            ChatMessage(
                id=m.id,
                chat_id=chat_id,
                sender_id=m.sender_id,
                text=m.text,
                created_at=m.created_at,
            )
        )
        if len(to_create) >= batch_size:
            ChatMessage.objects.bulk_create(to_create)
            to_create.clear()

    if to_create:
        ChatMessage.objects.bulk_create(to_create)

    # Apply unread counts + last_read per member.
    for (u1, u2), chat_id in pair_to_chat_id.items():
        pair = (u1, u2)
        lm_id = last_id.get(pair)
        for uid in (u1, u2):
            unread = unread_by_pair_user.get((pair, uid), 0)
            updates = {"unread_count": unread}
            if unread == 0 and lm_id:
                updates["last_read_message_id"] = lm_id
            ChatMember.objects.filter(chat_id=chat_id, user_id=uid).update(**updates)


def backwards(apps, schema_editor):
    # No automatic rollback (legacy Message table is preserved).
    return


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0012_chat_models"),
    ]

    operations = [
        migrations.RunPython(forwards, backwards),
    ]
